# mallocの内部
この記事は[glibc wiki MallocInternals](https://sourceware.org/glibc/wiki/MallocInternals)の自分用まとめ記事です。

## mallocの概要
GNU C library(以下glibc) mallocライブラリはアプリケーションのアドレス空間に確保されたメモリを管理する、使い勝手の良い関数を提供している。
このmallocは"ヒープ"スタイル、つまり大きなメモリ領域("ヒープ")に色んなサイズのチャンクがある。
昔はアプリケーション1つにつき、1つのヒープだったが、glibcでは複数のヒープを持つことができ、それぞれのヒープはその中で大きくなっていく。

## 用語
- アリーナ 
1つ以上のスレッドに共有される構造体で、1つ以上のヒープへの参照と解放されたヒープ内のチャンクのリンクリストを持つ。

- ヒープ
連続したメモリ領域で、メモリ確保に使われるチャンクに分割されている。
各ヒープはただ1つのアリーナに属する。

- チャンク
小さなメモリ領域で、アプリケーションに所有されるメモリとして確保したり、glibcに返すために解放したり、隣接するチャンク同士を大きな領域に結合できる。

- メモリ
アプリケーションのアドレス空間の一部で、RAMやスワップ領域にあることが多い。

以下の議論では関係ないので、明示しない限り、仮想メモリと実メモリを区別しない。

## チャンクとは？
glibcはチャンク指向である。
大きなメモリ領域(ヒープ)を色んなサイズのチャンクに分割し、各チャンクにそれがどれくらい大きいのかについてのメタデータを含ませる(これによって、次のチャンクの位置がわかる)。
チャンクが使用中なら、保存されているメタデータはチャンクのサイズだけである。
チャンクが解放されているなら、以前はアプリケーションデータだったメモリはリンクリスト内のポインターのような、アリーナに関する追加の情報のために再利用され、その結果、必要な時に素早く見つけて再利用される。
また、解放されたチャンクの最後のワード(ポインタのサイズ分のメモリ)にはチャンクのサイズがコピーされる(下位3ビットは0がセットされる(すぐ後で解説))。

mallocライブラリでは、チャンクポインターや`mchunkptr`はチャンクの最初を指さず、前のチャンクの最後のワードを指す。
つまり、`mchunkptr`の最初のワードは前のチャンクが解放されていると知ってないと有効ではない。

全てのチャンクは8バイトの倍数なので、実はチャンクの先頭ワードにある、チャンクのサイズの下位3ビットはフラグのために使われている(`mchunkptr`の下位3ビットは0と説明したのはこのため)。

各フラグの意味は以下の通り。

- A (0x04)
メインアリーナはアプリケーションヒープを使う。
他のアリーナはmmapのヒープを使う。
チャンクをヒープにマップするには、どちらのケースなのか知る必要がある。
このビットが0なら、チャンクはメインアリーナのメインヒープから来ている。
1なら、mmapのメモリから来ていて、ヒープの場所はチャンクのアドレスから計算される。

- M (0x02)
このチャンクがmmapで確保され、ヒープの一部ではない時に1？。

- P (0x01)
前のチャンクが使用中なら1。
正確には、前のチャンクを結合すべきでない時に1になる。

チャンクの最小サイズは`4 * sizeof(void*)`。
プラットフォームのABIが追加のアラインメントを要求するなら、最小チャンクサイズはより大きいかもしれない。

確保されたヒープは必ず2のべき乗にアラインされる。
なので、チャンクが確保されたヒープにある(つまりAビットが立っている)時、そのヒープの`heap_info`のアドレスはチャンクのアドレスに基づいて計算される。

## アリーナとヒープ
効率よくマルチスレッドアプリケーションを扱うために、glibcのmallocは同時に複数のメモリ領域を持つことを許可している。
これによって、異なるスレッドが異なるメモリ領域を互いに干渉せずにアクセスできる。
これらの領域をまとめてアリーナと呼ぶ。
アプリケーションの初期ヒープに対応する"メインアリーナ"がある。
また、このアリーナを指すmallocのコード内の静的変数があり、各アリーナは追加のアリーナをリンクするために次のアリーナを指すポインター`next`を持つ。

アリーナの数はシステムのCPUの数の8倍までに制限されている。
スレッドを多用しているアプリケーションはまだ不満がある？だろうが、フラグメンテーションが少なくなることとのトレードオフになる。

各アリーナはアクセス制御に使われるミューテックスを1つ持つ。
ファーストビンへのアクセスのような、いくつかの操作はアトミック演算で実行でき、アリーナをロックする必要がない。その他の操作を行うにはスレッドがアリーナのロックを獲得する必要がある。

各アリーナは1つ以上のヒープからメモリを得る。
メインアリーナはプログラムの初期ヒープを使う。
追加されたアリーナはmmapを使って、自身のヒープのためにメモリを確保し、古いヒープが一杯になったら自身のヒープのリストにさらにヒープを追加する。
各アリーナは特別な"トップ"チャンクを追跡し続ける。
これは通常、最も大きな利用可能なチャンクで、最も新しく確保されたヒープに含まれている。

アリーナの構造体はそのアリーナの初期ヒープのチャンクから確保される。

各アリーナ内で、チャンクはアプリケーションによって使用中かフリー(利用可能)かのどちらかである。
使用中のチャンクはアリーナによって追跡されない。
フリーチャンクはサイズとヒストリーに基づいた、様々なリストに保存される。
その結果、ライブラリは確保要求に合ったチャンクを素早く見つけることができる。
このリストは"ビン"と呼ばれ、以下の種類がある:

- Fast

